var documenterSearchIndex = {"docs":
[{"location":"api/model/#Model-API","page":"Model","title":"Model API","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"The Model is the central component of JuLS that orchestrates the optimization process.","category":"page"},{"location":"api/model/#Model-Creation","page":"Model","title":"Model Creation","text":"","category":"section"},{"location":"api/model/#JuLS.init_model","page":"Model","title":"JuLS.init_model","text":"init_model(\n    e::Experiment;\n    init::InitializationHeuristic = default_init(e),\n    neigh::NeighbourhoodHeuristic = default_neigh(e),\n    pick::MoveSelectionHeuristic = default_pick(e),\n    using_cp::Bool = default_using_cp(e)\n)\n\nInitializes an optimization model for the given experiment.\n\nProcess\n\nGenerates variable domains\nCreates initial solution\nGenerates decision variables\nCreates and initializes DAG\nConfigures model with specified heuristics and CP settings \n\n\n\n\n\n","category":"function"},{"location":"api/model/#Optimization","page":"Model","title":"Optimization","text":"","category":"section"},{"location":"api/model/#JuLS.optimize!","page":"Model","title":"JuLS.optimize!","text":"optimize!(model::AbstractModel; \n         rng = Random.GLOBAL_RNG, \n         n_iterations::Int = 100)\n\nMain optimization function that iteratively improves the solution.\n\nArguments\n\nmodel::AbstractModel: Model to optimize\nrng: Random number generator\nn_iterations::Int: Number of iterations to perform\n\n\n\n\n\n","category":"function"},{"location":"api/model/#Limits","page":"Model","title":"Limits","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"IterationLimit(n): Stop after n iterations\nTimeLimit(seconds): Stop after specified time in seconds","category":"page"},{"location":"api/model/#Model-Structure","page":"Model","title":"Model Structure","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"The Model struct contains the following key fields:","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"experiment: The problem definition\ncurrent_solution: Current solution state\nbest_solution: Best solution found so far\ndag: The constraint/objective DAG\nheuristics: Collection of heuristics used\nmetrics: Performance metrics and statistics","category":"page"},{"location":"api/model/#Solution-Access","page":"Model","title":"Solution Access","text":"","category":"section"},{"location":"api/model/#Current-Solution","page":"Model","title":"Current Solution","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Access the current solution state:","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"model.current_solution.values      # Current variable values\nmodel.current_solution.objective   # Current objective value\nmodel.current_solution.feasible    # Feasibility status","category":"page"},{"location":"api/model/#Best-Solution","page":"Model","title":"Best Solution","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Access the best solution found:","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"model.best_solution.values         # Best variable values\nmodel.best_solution.objective      # Best objective value","category":"page"},{"location":"api/model/#Metrics-and-Statistics","page":"Model","title":"Metrics and Statistics","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"The model tracks various metrics during optimization:","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"model.run_metrics","category":"page"},{"location":"api/model/#Example-Usage","page":"Model","title":"Example Usage","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"using JuLS\n\n# Create experiment\ndata_path = joinpath(JuLS.PROJECT_ROOT, \"data\", \"knapsack\", \"ks_4_0\")\nexperiment = KnapsackExperiment(data_path)\n\n# Initialize model\nmodel = init_model(\n    experiment;\n    init = SimpleInitialization(),\n    neigh = BinaryRandomNeighbourhood(10, 2),  # 10 moves, 2 variables per move\n    pick = GreedyMoveSelection(),\n    using_cp = true\n)\n\n# Optimize\noptimize!(model; limit = IterationLimit(1000))\n\n# Access results\nprintln(\"Best objective: \", model.best_solution.objective)\nprintln(\"Best solution: \", model.best_solution.values)","category":"page"},{"location":"api/model/#Advanced-Usage","page":"Model","title":"Advanced Usage","text":"","category":"section"},{"location":"api/model/#Custom-Stopping-Criteria","page":"Model","title":"Custom Stopping Criteria","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"You can implement custom stopping criteria by extending the Limit types.","category":"page"},{"location":"api/model/#Model-Inspection","page":"Model","title":"Model Inspection","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"During optimization, you can inspect the model state:","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"# Check if current solution is feasible\nis_feasible = model.current_solution.feasible\n\n# Get constraint violations\nviolations = get_violations(model.dag)\n\n# Access move history\nrecent_moves = model.move_history[end-10:end]","category":"page"},{"location":"api/model/#Performance-Considerations","page":"Model","title":"Performance Considerations","text":"","category":"section"},{"location":"api/model/#Memory-Usage","page":"Model","title":"Memory Usage","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"The model stores solution history for analysis\nConsider smaller neighbourhood sizes for large problems","category":"page"},{"location":"api/model/#Threading","page":"Model","title":"Threading","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"JuLS can utilize multiple threads for move evaluation\nStart Julia with --threads=auto for best performance\nSome heuristics are inherently sequential","category":"page"},{"location":"api/model/#Constraint-Programming-Integration","page":"Model","title":"Constraint Programming Integration","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"When using_cp = true:","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"Move filtering is more efficient but requires more memory\nCP solver state is maintained alongside the DAG\nInfeasible moves are filtered before evaluation","category":"page"},{"location":"api/model/#Troubleshooting","page":"Model","title":"Troubleshooting","text":"","category":"section"},{"location":"api/model/#Common-Issues","page":"Model","title":"Common Issues","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"No improvements found: Try different heuristic combinations\nMemory issues: Reduce neighbourhood size or clear history\nSlow convergence: Enable CP filtering or use better initialization\nInfeasible solutions: Check constraint definitions in DAG","category":"page"},{"location":"guide/cp/#Constraint-Programming","page":"Constraint Programming","title":"Constraint Programming","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"JuLS integrates Constraint Programming (CP) to efficiently filter infeasible moves during local search optimization.","category":"page"},{"location":"guide/cp/#What-is-CP-Integration?","page":"Constraint Programming","title":"What is CP Integration?","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"When you set using_cp = true in your model, JuLS:","category":"page"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"Converts the DAG to CP constraints\nUses CP propagation to filter moves\nMaintains consistency between DAG and CP representations","category":"page"},{"location":"guide/cp/#Benefits-of-CP-Integration","page":"Constraint Programming","title":"Benefits of CP Integration","text":"","category":"section"},{"location":"guide/cp/#Move-Filtering","page":"Constraint Programming","title":"Move Filtering","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"Eliminates infeasible moves before evaluation\nReduces wasted computation on invalid solutions\nImproves search efficiency","category":"page"},{"location":"guide/cp/#Constraint-Propagation","page":"Constraint Programming","title":"Constraint Propagation","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"Automatically enforces constraint consistency\nDetects infeasibility early\nProvides domain reduction","category":"page"},{"location":"guide/cp/#How-It-Works","page":"Constraint Programming","title":"How It Works","text":"","category":"section"},{"location":"guide/cp/#DAG-to-CP-Conversion","page":"Constraint Programming","title":"DAG to CP Conversion","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"The DAG invariants are automatically converted to CP constraints:","category":"page"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"# DAG invariants\nsum_invariant = ScalarProductInvariant(weights)\ncomparator = ComparatorInvariant(capacity)\n\n# Becomes CP constraint\nsum_constraint = SumLessThan(weights, capacity)","category":"page"},{"location":"guide/cp/#Move-Evaluation-Process","page":"Constraint Programming","title":"Move Evaluation Process","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"Generate candidate moves from neighbourhood\nApply CP filtering to eliminate infeasible moves\nEvaluate remaining moves using DAG\nSelect best move using move selection heuristic","category":"page"},{"location":"guide/cp/#CP-Variable-Types","page":"Constraint Programming","title":"CP Variable Types","text":"","category":"section"},{"location":"guide/cp/#IntVariable","page":"Constraint Programming","title":"IntVariable","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"For integer decision variables:","category":"page"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"var = IntVariable(1, 10)  # Domain [1, 10]","category":"page"},{"location":"guide/cp/#BoolVariable","page":"Constraint Programming","title":"BoolVariable","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"For binary decision variables:","category":"page"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"var = BoolVariable()  # Domain {0, 1}","category":"page"},{"location":"guide/cp/#CP-Constraints","page":"Constraint Programming","title":"CP Constraints","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"JuLS provides several built-in CP constraints:","category":"page"},{"location":"guide/cp/#Basic-Constraints","page":"Constraint Programming","title":"Basic Constraints","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"Equal: Variable equality\nNotEqual: Variable inequality\nSumLessThan: Weighted sum constraints","category":"page"},{"location":"guide/cp/#Advanced-Constraints","page":"Constraint Programming","title":"Advanced Constraints","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"AllDifferent: All variables must be different\nAmong: Count constraints\nElement: Array indexing","category":"page"},{"location":"guide/cp/#Example:-Knapsack-with-CP","page":"Constraint Programming","title":"Example: Knapsack with CP","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"using JuLS\n\n# Load experiment\nexperiment = KnapsackExperiment(\"data/knapsack/ks_4_0\")\n\n# Create model with CP enabled\nmodel = init_model(\n    experiment;\n    init = SimpleInitialization(),\n    neigh = BinaryRandomNeighbourhood(10, 2),  # n_moves, n_vars\n    pick = GreedyMoveSelection(),\n    using_cp = true  # Enable CP filtering\n)\n\n# Optimize - CP will filter infeasible moves\noptimize!(model; limit = IterationLimit(1000))","category":"page"},{"location":"guide/cp/#Next-Steps","page":"Constraint Programming","title":"Next Steps","text":"","category":"section"},{"location":"guide/cp/","page":"Constraint Programming","title":"Constraint Programming","text":"See Examples for CP usage in practice\nLearn about DAG and Invariants for constraint modeling\nExplore the API Reference for detailed CP documentation","category":"page"},{"location":"guide/dag/#DAG-and-Invariants","page":"DAG and Invariants","title":"DAG and Invariants","text":"","category":"section"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"The Directed Acyclic Graph (DAG) is the core structure in JuLS that represents constraints and objectives of your optimization problem.","category":"page"},{"location":"guide/dag/#What-is-an-Invariant?","page":"DAG and Invariants","title":"What is an Invariant?","text":"","category":"section"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"An invariant is a fixed relation between a set of input variables and a single output variable.","category":"page"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"As a pedagogical example, an invariant I can represent the constraint z = x+ y, where the set of input variables would {x, y} and the output variable would be z.","category":"page"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"An invariant can as well be a far more complex or even black-box relation.","category":"page"},{"location":"guide/dag/#What-is-a-DAG?","page":"DAG and Invariants","title":"What is a DAG?","text":"","category":"section"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"A DAG is a Directed Acyclic Graph of invariants. Through this graph, the optimization objective and constraints are represented.","category":"page"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"To see how a DAG of invariants is constructed, you are encouraged to read the source code of our toy examples (for example the Knapsack).","category":"page"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"The DAG uses message passing to:","category":"page"},{"location":"guide/dag/","page":"DAG and Invariants","title":"DAG and Invariants","text":"Propagate changes efficiently\nMaintain constraint consistency\nCompute objective values incrementally","category":"page"},{"location":"api/experiments/#Experiments-API","page":"Experiments","title":"Experiments API","text":"","category":"section"},{"location":"api/experiments/","page":"Experiments","title":"Experiments","text":"The Experiments API provides the problem definitions and data handling functionality.","category":"page"},{"location":"api/experiments/#Built-in-Experiments","page":"Experiments","title":"Built-in Experiments","text":"","category":"section"},{"location":"api/experiments/#JuLS.KnapsackExperiment","page":"Experiments","title":"JuLS.KnapsackExperiment","text":"KnapsackExperiment <: Experiment\n\nRepresents a 0-1 Knapsack Problem experiment instance.\n\nFields\n\ninput_file::String: Path to file containing problem data\nα::Float64: Penalty parameter for constraint violation\nn_items::Int: Number of items\ncapacity::Int: Knapsack capacity\nvalues::Vector{Int}: Values of items\nweights::Vector{Int}: Weights of items\n\nFile Format\n\nExpected input file format:\n\nnitems capacity value1 weight1 value2 weight2 ... valuen weight_n\n\n\n\n\n\n","category":"type"},{"location":"api/experiments/#JuLS.TSPExperiment","page":"Experiments","title":"JuLS.TSPExperiment","text":"TSPExperiment <: Experiment\n\nRepresents a Traveling Salesman Problem (TSP) experiment instance.\n\nFields\n\ninput_file::String: Path to file containing city coordinates\nn_nodes::Int: Number of cities\ndistance_matrix::Matrix{Float64}: Matrix of pairwise distances between cities. The distance is L2 rounded to the closest integer.\n\nFile Format\n\nExpected input file format:\n\nn_nodes x1 y1 x2 y2 ... xn yn\n\nWhere (xi,yi) are coordinates of city i.\n\n\n\n\n\n","category":"type"},{"location":"api/experiments/#JuLS.GraphColoringExperiment","page":"Experiments","title":"JuLS.GraphColoringExperiment","text":"GraphColoringExperiment <: Experiment\n\nRepresents a Graph Coloring Problem experiment instance.\n\nFields\n\ninput_file::String: Path to file containing problem data\nmax_color::Int: Maximum number of color for this problem\nα::Float64: Penalty parameter for constraint violation\nn_nodes::Int: Number of nodes\nn_edges::Int: Number of edges\ngreedy_coloring::Vector{Int}: Coloration with greedy algorithm\nedges::Vector{Tuple{Int,Int}}: List of edges\n\nFile Format\n\nExpected input file format:\n\nnnodes nedges node11 node12 (edge 1) node21 node22 (edge 2) ... noden1 noden2 (edge n)\n\n\n\n\n\n","category":"type"},{"location":"api/experiments/#Experiment-Interface","page":"Experiments","title":"Experiment Interface","text":"","category":"section"},{"location":"api/experiments/","page":"Experiments","title":"Experiments","text":"All experiments must implement the following interface:","category":"page"},{"location":"api/experiments/","page":"Experiments","title":"Experiments","text":"n_decision_variables(experiment): Return the number of decision variables\ndecision_type(experiment): Return the type of decision variables  \ngenerate_domains(experiment): Return the domains for each variable\ncreate_dag(experiment): Return the DAG representation of the problem","category":"page"},{"location":"api/constraints/#Constraints-API","page":"Constraints","title":"Constraints API","text":"","category":"section"},{"location":"api/constraints/","page":"Constraints","title":"Constraints","text":"The Constraints API provides the constraint programming functionality for move filtering.","category":"page"},{"location":"api/constraints/#CP-Variables","page":"Constraints","title":"CP Variables","text":"","category":"section"},{"location":"api/constraints/#IntVariable","page":"Constraints","title":"IntVariable","text":"","category":"section"},{"location":"api/constraints/#JuLS.IntVariable","page":"Constraints","title":"JuLS.IntVariable","text":"struct IntVariable <: CPVariable\n\nA \"simple\" integer variable, whose domain can be any set of integers. The constraints that affect this variable are stored in the on_domain_change array.\n\n\n\n\n\n","category":"type"},{"location":"api/constraints/#BoolVariable","page":"Constraints","title":"BoolVariable","text":"","category":"section"},{"location":"api/constraints/#JuLS.BoolVariable","page":"Constraints","title":"JuLS.BoolVariable","text":"struct BoolVariable <: AbstractVar\n\nA \"simple\" boolean variable. The constraints that affect this variable are stored in the on_domain_change array.\n\n\n\n\n\n","category":"type"},{"location":"api/constraints/#CP-Constraints","page":"Constraints","title":"CP Constraints","text":"","category":"section"},{"location":"api/constraints/#Basic-Constraints","page":"Constraints","title":"Basic Constraints","text":"","category":"section"},{"location":"api/constraints/#JuLS.Equal","page":"Constraints","title":"JuLS.Equal","text":"struct Equal <: CPConstraint\n\nCPConstraint x = y\n\n\n\n\n\n","category":"type"},{"location":"api/constraints/#JuLS.NotEqual","page":"Constraints","title":"JuLS.NotEqual","text":"struct NotEqual <: CPConstraint\n\nCPConstraint x != y between two CPVariables x and y.\n\n\n\n\n\n","category":"type"},{"location":"api/constraints/#JuLS.SumLessThan","page":"Constraints","title":"JuLS.SumLessThan","text":"struct SumLessThan <: CPConstraint\n\nCPConstraint ∑(x_i ∀ i ∈ |x|) ≤ upper\n\nFiltering:  The goal is to enforce the constraint: ∑(x_i ∀ i ∈ |x|) ≤ upper\n\nWe can rewrite as: xi + ∑(xj ∀ j != i) ≤ upper → xi ≤ - ∑(xj ∀ j != i) + upper\n\nTherefore, the tighest bound on xi (maximum value xi can take) is:  xi = - ∑(xj ∀ j != i) + upper\n\nWe know that: \n\n∑(xj ∀ j != i) ≤ - ∑(min(xj) ∀ j != i)\n∑(min(xj) ∀ j != i) = min(xi) - ∑(min(x_i) ∀ i ∈ |x|)\n\nRewrite:\n\n∑(xj ∀ j != i) ≤ min(xi) - ∑(min(xi) ∀ i ∈ |x|)  xi - upper    ≤ min(xi) - ∑(min(xi) ∀ i ∈ |x|)\n\n⟹ xi ≤ min(xi) - ∑(min(x_i) ∀ i ∈ |x|) + upper This means that we can prune all values greater than - ∑(min(xj) ∀ j != i) + upper from xi's domain\n\n\n\n\n\n","category":"type"},{"location":"api/constraints/#Integration-with-DAG","page":"Constraints","title":"Integration with DAG","text":"","category":"section"},{"location":"api/constraints/","page":"Constraints","title":"Constraints","text":"CP constraints are automatically generated from DAG invariants when using_cp = true.","category":"page"},{"location":"examples/graph_coloring/#Graph-Coloring-Problem-Example","page":"Graph Coloring Problem","title":"Graph Coloring Problem Example","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"This example demonstrates how to solve a graph coloring problem using JuLS.jl.","category":"page"},{"location":"examples/graph_coloring/#Problem-Description","page":"Graph Coloring Problem","title":"Problem Description","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"The Graph Coloring Problem involves:","category":"page"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"A graph with vertices and edges\nGoal: assign colors to vertices such that no adjacent vertices have the same color\nMinimize the number of colors used","category":"page"},{"location":"examples/graph_coloring/#Basic-Usage","page":"Graph Coloring Problem","title":"Basic Usage","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"using JuLS\n\n# Load a graph coloring instance\ndata_path = joinpath(JuLS.PROJECT_ROOT, \"data\", \"graph_coloring\", \"gc_4_1\")\nexperiment = GraphColoringExperiment(data_path, 4)  # 4 colors max\n\n# Create and run the model\nmodel = init_model(\n    experiment;\n    init = GreedyInitialization(),\n    neigh = RandomNeighbourhood(4, 1),  # 4 variables, 1 to move\n    pick = GreedyMoveSelection(),\n    using_cp = true\n)\n\n# Optimize for 1000 iterations\noptimize!(model; limit = IterationLimit(1000))\n\n# Display results\nprintln(\"Colors used: \", model.best_solution.objective)\nprintln(\"Coloring: \", model.best_solution.values)","category":"page"},{"location":"examples/graph_coloring/#Data-Format","page":"Graph Coloring Problem","title":"Data Format","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"Graph coloring data files specify the edges in the graph.","category":"page"},{"location":"examples/graph_coloring/#Initialization-Strategies","page":"Graph Coloring Problem","title":"Initialization Strategies","text":"","category":"section"},{"location":"examples/graph_coloring/#Greedy-Coloring","page":"Graph Coloring Problem","title":"Greedy Coloring","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"Assigns colors greedily:","category":"page"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"init = GreedyInitialization()","category":"page"},{"location":"examples/graph_coloring/#Random-Initialization","page":"Graph Coloring Problem","title":"Random Initialization","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"Random color assignment:","category":"page"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"init = SimpleInitialization()","category":"page"},{"location":"examples/graph_coloring/#Neighbourhood-Strategies","page":"Graph Coloring Problem","title":"Neighbourhood Strategies","text":"","category":"section"},{"location":"examples/graph_coloring/#Random-Neighbourhood","page":"Graph Coloring Problem","title":"Random Neighbourhood","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"Changes colors of random vertices:","category":"page"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"neigh = RandomNeighbourhood()","category":"page"},{"location":"examples/graph_coloring/#Move-Selection","page":"Graph Coloring Problem","title":"Move Selection","text":"","category":"section"},{"location":"examples/graph_coloring/#Greedy-Selection","page":"Graph Coloring Problem","title":"Greedy Selection","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"Always picks the best move:","category":"page"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"pick = GreedyMoveSelection()","category":"page"},{"location":"examples/graph_coloring/#Next-Steps","page":"Graph Coloring Problem","title":"Next Steps","text":"","category":"section"},{"location":"examples/graph_coloring/","page":"Graph Coloring Problem","title":"Graph Coloring Problem","text":"Return to Knapsack Example\nLearn about Custom Experiments\nExplore Heuristic combinations","category":"page"},{"location":"guide/experiments/#Creating-Experiments","page":"Creating Experiments","title":"Creating Experiments","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Experiments in JuLS define the structure and data of optimization problems. They serve as the foundation for setting up your optimization model.","category":"page"},{"location":"guide/experiments/#What-is-an-Experiment?","page":"Creating Experiments","title":"What is an Experiment?","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"An experiment is a Julia struct that inherits from the abstract type Experiment and encapsulates:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Problem instance data\nDecision variable definitions\nDomain generation logic\nProblem-specific initialization methods","category":"page"},{"location":"guide/experiments/#Required-Interface","page":"Creating Experiments","title":"Required Interface","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Every experiment must implement the following functions:","category":"page"},{"location":"guide/experiments/#Core-Functions","page":"Creating Experiments","title":"Core Functions","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"# Define the number of decision variables\nn_decision_variables(e::YourExperiment)::Int\n\n# Define the type of decision variables\ndecision_type(e::YourExperiment)::Type\n\n# Generate domains for decision variables\ngenerate_domains(e::YourExperiment)::Vector\n\n# Create the DAG representation of the problem\ncreate_dag(e::YourExperiment)::DAG","category":"page"},{"location":"guide/experiments/#Initialization-Function","page":"Creating Experiments","title":"Initialization Function","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"# Define how to initialize solutions\n(::SimpleInitialization)(e::YourExperiment)::Vector","category":"page"},{"location":"guide/experiments/#Decision-Variable-Types","page":"Creating Experiments","title":"Decision Variable Types","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"JuLS supports several decision variable types:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"BinaryDecisionValue: For 0/1 variables\nIntDecisionValue: For integer variables with bounds\nPermutationDecisionValue: For permutation problems","category":"page"},{"location":"guide/experiments/#Example:-Custom-Experiment","page":"Creating Experiments","title":"Example: Custom Experiment","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Here's how to create a simple custom experiment:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"using JuLS\n\n# Define your experiment struct\nstruct MyCustomExperiment <: Experiment\n    n_vars::Int\n    bounds::Vector{Tuple{Int,Int}}\n    objective_weights::Vector{Float64}\nend\n\n# Implement required functions\nfunction n_decision_variables(e::MyCustomExperiment)\n    return e.n_vars\nend\n\nfunction decision_type(e::MyCustomExperiment)\n    return IntDecisionValue\nend\n\nfunction generate_domains(e::MyCustomExperiment)\n    domains = []\n    for (lower, upper) in e.bounds\n        push!(domains, lower:upper)\n    end\n    return domains\nend\n\nfunction create_dag(e::MyCustomExperiment)\n    # Create your DAG here\n    # This defines the constraints and objectives\n    dag = DAG(1)\n    \n    # Add invariants to represent your problem\n    # See the DAG guide for details\n    \n    return dag\nend\n\n# Define initialization\nfunction (::SimpleInitialization)(e::MyCustomExperiment)\n    solution = []\n    for (lower, upper) in e.bounds\n        push!(solution, rand(lower:upper))\n    end\n    return solution\nend","category":"page"},{"location":"guide/experiments/#Built-in-Experiments","page":"Creating Experiments","title":"Built-in Experiments","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"JuLS provides several built-in experiments:","category":"page"},{"location":"guide/experiments/#KnapsackExperiment","page":"Creating Experiments","title":"KnapsackExperiment","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"For binary knapsack problems:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"experiment = KnapsackExperiment(\"path/to/data/file\")","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"The data file should contain:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"First line: number of items, knapsack capacity\nFollowing lines: weight, value for each item","category":"page"},{"location":"guide/experiments/#TSPExperiment","page":"Creating Experiments","title":"TSPExperiment","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"For traveling salesman problems:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"experiment = TSPExperiment(\"path/to/tsp/file\")","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Supports standard TSP file formats with distance matrices.","category":"page"},{"location":"guide/experiments/#GraphColoringExperiment","page":"Creating Experiments","title":"GraphColoringExperiment","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"For graph coloring problems:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"experiment = GraphColoringExperiment(\"path/to/graph/file\", n_colors)","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Where n_colors is the number of colors to use. The graph file should specify edges in the graph.","category":"page"},{"location":"guide/experiments/#Best-Practices","page":"Creating Experiments","title":"Best Practices","text":"","category":"section"},{"location":"guide/experiments/#Data-Loading","page":"Creating Experiments","title":"Data Loading","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Load and validate data in the constructor\nStore preprocessed data as struct fields\nHandle file format errors gracefully","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"struct MyExperiment <: Experiment\n    data::Matrix{Float64}\n    \n    function MyExperiment(filepath::String)\n        # Load and validate data\n        if !isfile(filepath)\n            error(\"Data file not found: $filepath\")\n        end\n        \n        data = load_data(filepath)\n        validate_data(data)\n        \n        new(data)\n    end\nend","category":"page"},{"location":"guide/experiments/#Domain-Generation","page":"Creating Experiments","title":"Domain Generation","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Use efficient data structures for large domains\nConsider domain reduction techniques\nCache domains if they're expensive to compute","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"function generate_domains(e::MyExperiment)\n    # Cache domains if needed\n    if !isdefined(e, :cached_domains)\n        e.cached_domains = compute_domains(e)\n    end\n    return e.cached_domains\nend","category":"page"},{"location":"guide/experiments/#DAG-Construction","page":"Creating Experiments","title":"DAG Construction","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Keep DAG construction modular\nUse helper functions for complex constraints\nDocument the problem formulation","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"function create_dag(e::MyExperiment)\n    dag = DAG()\n    \n    # Add constraints systematically\n    add_capacity_constraints!(dag, e)\n    add_objective_function!(dag, e)\n    add_problem_specific_constraints!(dag, e)\n    \n    return dag\nend","category":"page"},{"location":"guide/experiments/#Testing-Your-Experiment","page":"Creating Experiments","title":"Testing Your Experiment","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Always test your experiment implementation:","category":"page"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"# Test basic functionality\nexperiment = MyCustomExperiment(...)\n\n@test n_decision_variables(experiment) > 0\n@test decision_type(experiment) <: DecisionValue\n@test length(generate_domains(experiment)) == n_decision_variables(experiment)\n\n# Test with a model\nmodel = init_model(experiment)\n@test model isa Model\n\n# Test optimization\noptimize!(model; limit = IterationLimit(10))\n@test model.best_solution.objective isa Number","category":"page"},{"location":"guide/experiments/#Common-Pitfalls","page":"Creating Experiments","title":"Common Pitfalls","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Inconsistent dimensions: Ensure all arrays have consistent sizes\nInvalid domains: Check that domains are non-empty and valid\nMissing exports: Don't forget to export your experiment type\nPerformance issues: Profile domain generation and DAG construction for large instances","category":"page"},{"location":"guide/experiments/#Next-Steps","page":"Creating Experiments","title":"Next Steps","text":"","category":"section"},{"location":"guide/experiments/","page":"Creating Experiments","title":"Creating Experiments","text":"Learn about DAG and Invariants to define your problem constraints\nExplore Heuristics to customize the optimization process\nSee complete Examples for reference implementations","category":"page"},{"location":"guide/heuristics/#Heuristics","page":"Heuristics","title":"Heuristics","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Heuristics in JuLS control how the optimization process explores the solution space. They are divided into three main categories: initialization, neighbourhood exploration, and move selection.","category":"page"},{"location":"guide/heuristics/#Types-of-Heuristics","page":"Heuristics","title":"Types of Heuristics","text":"","category":"section"},{"location":"guide/heuristics/#1.-Initialization-Heuristics","page":"Heuristics","title":"1. Initialization Heuristics","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"These determine the starting solution for optimization.","category":"page"},{"location":"guide/heuristics/#SimpleInitialization","page":"Heuristics","title":"SimpleInitialization","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Random initialization within variable domains:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"init = SimpleInitialization()","category":"page"},{"location":"guide/heuristics/#GreedyInitialization","page":"Heuristics","title":"GreedyInitialization","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Problem-specific greedy construction:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"init = GreedyInitialization()","category":"page"},{"location":"guide/heuristics/#ChristofidesInitialization","page":"Heuristics","title":"ChristofidesInitialization","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Specialized for TSP problems using the Christofides algorithm:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"init = ChristofidesInitialization()","category":"page"},{"location":"guide/heuristics/#2.-Neighbourhood-Heuristics","page":"Heuristics","title":"2. Neighbourhood Heuristics","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"These define how to explore the solution space by generating moves.","category":"page"},{"location":"guide/heuristics/#RandomNeighbourhood","page":"Heuristics","title":"RandomNeighbourhood","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Randomly selects variables and generates moves:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"neigh = RandomNeighbourhood(n_vars, n_to_move)  # n_vars total, n_to_move selected","category":"page"},{"location":"guide/heuristics/#BinaryRandomNeighbourhood","page":"Heuristics","title":"BinaryRandomNeighbourhood","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Specialized for binary problems:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"neigh = BinaryRandomNeighbourhood(n_moves, n_vars)  # n_moves generated, n_vars flipped each","category":"page"},{"location":"guide/heuristics/#SwapNeighbourhood","page":"Heuristics","title":"SwapNeighbourhood","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Generates swap moves between variables:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"neigh = SwapNeighbourhood()  # No parameters needed","category":"page"},{"location":"guide/heuristics/#KOptNeighbourhood","page":"Heuristics","title":"KOptNeighbourhood","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"k-opt moves for permutation problems:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"neigh = KOptNeighbourhood(n_moves, k)  # n_moves generated, k variables each","category":"page"},{"location":"guide/heuristics/#3.-Move-Selection-Heuristics","page":"Heuristics","title":"3. Move Selection Heuristics","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"These decide which moves to accept during optimization.","category":"page"},{"location":"guide/heuristics/#GreedyMoveSelection","page":"Heuristics","title":"GreedyMoveSelection","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Always accepts the best improving move:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"pick = GreedyMoveSelection()","category":"page"},{"location":"guide/heuristics/#SimulatedAnnealing","page":"Heuristics","title":"SimulatedAnnealing","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Temperature-based acceptance with cooling:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"pick = SimulatedAnnealing(T0=100.0, α=0.95)","category":"page"},{"location":"guide/heuristics/#Metropolis","page":"Heuristics","title":"Metropolis","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Metropolis criterion with fixed temperature:","category":"page"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"pick = Metropolis(T=10.0)","category":"page"},{"location":"guide/heuristics/#Custom-Heuristics","page":"Heuristics","title":"Custom Heuristics","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"You can create custom heuristics by implementing the appropriate interfaces.","category":"page"},{"location":"guide/heuristics/#Custom-Initialization","page":"Heuristics","title":"Custom Initialization","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"struct MyInitialization <: InitializationHeuristic\n    # Custom parameters\nend\n\nfunction (init::MyInitialization)(experiment::MyExperiment)\n    # Return initial solution vector\n    return initial_solution\nend","category":"page"},{"location":"guide/heuristics/#Custom-Neighbourhood","page":"Heuristics","title":"Custom Neighbourhood","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"struct MyNeighbourhood <: NeighbourhoodHeuristic\n    # Custom parameters\nend\n\nfunction get_neighbourhood(neigh::MyNeighbourhood, model::Model)\n    # Return vector of possible moves\n    return moves\nend","category":"page"},{"location":"guide/heuristics/#Custom-Move-Selection","page":"Heuristics","title":"Custom Move Selection","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"struct MyMoveSelection <: MoveSelectionHeuristic\n    # Custom parameters\nend\n\nfunction pick_a_move(picker::MyMoveSelection, evaluated_moves::Vector{<:MoveEvaluatorOutput})\n    # Return selected move or nothing\n    return selected_move\nend","category":"page"},{"location":"guide/heuristics/#Heuristic-Combinations","page":"Heuristics","title":"Heuristic Combinations","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"Different heuristic combinations work better for different problem types:","category":"page"},{"location":"guide/heuristics/#For-Binary-Problems","page":"Heuristics","title":"For Binary Problems","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"model = init_model(\n    experiment;\n    init = GreedyInitialization(),\n    neigh = BinaryRandomNeighbourhood(10, 2),\n    pick = GreedyMoveSelection()\n)","category":"page"},{"location":"guide/heuristics/#For-Permutation-Problems","page":"Heuristics","title":"For Permutation Problems","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"model = init_model(\n    experiment;\n    init = ChristofidesInitialization(),  # TSP-specific\n    neigh = KOptNeighbourhood(5, 2),  # 5 moves, 2-opt\n    pick = SimulatedAnnealing(100.0, 0.95)  # T0=100.0, α=0.95\n)","category":"page"},{"location":"guide/heuristics/#For-General-Integer-Problems","page":"Heuristics","title":"For General Integer Problems","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"model = init_model(\n    experiment;\n    init = SimpleInitialization(),\n    neigh = RandomNeighbourhood(10, 2),  # 10 variables, 2 to move\n    pick = Metropolis(5.0)  # T=5.0\n)","category":"page"},{"location":"guide/heuristics/#Next-Steps","page":"Heuristics","title":"Next Steps","text":"","category":"section"},{"location":"guide/heuristics/","page":"Heuristics","title":"Heuristics","text":"See Examples for heuristic usage in practice\nLearn about Constraint Programming integration\nExplore the API Reference for detailed documentation","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get up and running with JuLS.jl quickly.","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.6 or later\nGit (for cloning the repository)","category":"page"},{"location":"getting_started/#Installing-JuLS","page":"Getting Started","title":"Installing JuLS","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently, JuLS is not registered in the Julia General registry. To install it, clone the repository and activate the project:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/amazon-science/JuLS.git\ncd JuLS\njulia --threads=auto --project=.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In the Julia REPL, instantiate the project:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.instantiate()","category":"page"},{"location":"getting_started/#Your-First-Optimization","page":"Getting Started","title":"Your First Optimization","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's solve a simple knapsack problem to get familiar with JuLS:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using JuLS\n\n# Load example data\ndata_path = joinpath(JuLS.PROJECT_ROOT, \"data\", \"knapsack\", \"ks_4_0\")\nexperiment = KnapsackExperiment(data_path)\n\n# Create a model with default settings\nmodel = init_model(\n    experiment;\n    init = SimpleInitialization(),\n    neigh = BinaryRandomNeighbourhood(10, 2),  # 10 moves, 2 variables per move\n    pick = GreedyMoveSelection(),\n    using_cp = true\n)\n\n# Optimize for 100 iterations\noptimize!(model; limit = IterationLimit(100))\n\n# Check the results\nprintln(\"Best objective: \", model.best_solution.objective)\nprintln(\"Best solution: \", model.best_solution.values)","category":"page"},{"location":"getting_started/#Understanding-the-Components","page":"Getting Started","title":"Understanding the Components","text":"","category":"section"},{"location":"getting_started/#Experiments","page":"Getting Started","title":"Experiments","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"An experiment defines the problem structure and data. JuLS provides built-in experiments for:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"KnapsackExperiment: Binary knapsack problems\nTSPExperiment: Traveling salesman problems  \nGraphColoringExperiment: Graph coloring problems","category":"page"},{"location":"getting_started/#Initialization-Heuristics","page":"Getting Started","title":"Initialization Heuristics","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"These determine the starting solution:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SimpleInitialization(): Random initialization\nGreedyInitialization(): Greedy construction (problem-specific)\nChristofidesInitialization(): For TSP problems","category":"page"},{"location":"getting_started/#Neighbourhood-Heuristics","page":"Getting Started","title":"Neighbourhood Heuristics","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"These define how to explore the solution space:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"BinaryRandomNeighbourhood(n_moves, n_vars): For binary problems - generates nmoves by flipping nvars variables\nSwapNeighbourhood(): Swap-based moves between variables\nKOptNeighbourhood(n_moves, k): k-opt moves for permutation problems - generates n_moves with k variables each\nRandomNeighbourhood(n_vars, n_to_move): Random variable selection - selects ntomove from n_vars variables","category":"page"},{"location":"getting_started/#Move-Selection-Heuristics","page":"Getting Started","title":"Move Selection Heuristics","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"These choose which moves to accept:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"GreedyMoveSelection(): Always pick the best improving move\nSimulatedAnnealing(T0, α): Temperature-based acceptance with cooling (T0=initial temp, α=cooling rate)\nMetropolis(T): Metropolis criterion with fixed temperature T","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Read the User Guide for detailed explanations\nCheck out the Examples for complete problem implementations\nBrowse the API Reference for detailed function documentation","category":"page"},{"location":"getting_started/#Common-Issues","page":"Getting Started","title":"Common Issues","text":"","category":"section"},{"location":"getting_started/#Threading","page":"Getting Started","title":"Threading","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"JuLS can benefit from multiple threads. Start Julia with:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia --threads=auto --project=.","category":"page"},{"location":"getting_started/#Memory-Usage","page":"Getting Started","title":"Memory Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For large problems, consider:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Using smaller neighbourhood sizes\nImplementing custom move filters\nMonitoring memory usage during optimization","category":"page"},{"location":"getting_started/#Performance-Tips","page":"Getting Started","title":"Performance Tips","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Enable constraint programming with using_cp = true for better move filtering\nExperiment with different heuristic combinations\nUse time limits for consistent benchmarking: TimeLimit(60) for 60 seconds","category":"page"},{"location":"api/dag/#DAG-API","page":"DAG","title":"DAG API","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"The DAG (Directed Acyclic Graph) API provides the core constraint and objective modeling functionality.","category":"page"},{"location":"api/dag/#DAG-Construction","page":"DAG","title":"DAG Construction","text":"","category":"section"},{"location":"api/dag/#JuLS.DAG","page":"DAG","title":"JuLS.DAG","text":"struct DAG <: MoveEvaluator\n\nCore data structure representing an optimization problem as a Directed Acyclic Graph (DAG).  An invariant represents an intermediate relationship between variables. We represent these relationships as a Directed Acyclic Graph (DAG). This representation allows for cheap evaluations of local moves.\n\nFields\n\n_invariants::Vector{Invariant}: Problem invariants (nodes of the DAG)\n_names::Vector{Union{Nothing,String}}: Optional names for invariants\n_using_cp::BitVector: Flags for constraint programming usage per invariant\n_adjacency_matrix::AdjacencyMatrix: Graph structure representation\n_var_to_first_invariants::Vector{Int}: Maps variables to their first dependent invariants\n_early_stop_threshold::Float64: Threshold for early termination of move evaluation\n_helper::AbstractDAGHelper: Problem-specific helper object\n_is_init::Bool: Initialization status flag\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#Invariants","page":"DAG","title":"Invariants","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"Invariants are the building blocks of the DAG that represent constraints and computations.","category":"page"},{"location":"api/dag/#Arithmetic-Invariants","page":"DAG","title":"Arithmetic Invariants","text":"","category":"section"},{"location":"api/dag/#JuLS.ScalarProductInvariant","page":"DAG","title":"JuLS.ScalarProductInvariant","text":"ScalarProductInvariant <: Invariant\n\nInvariant to represent the scalar product  y = (w | x)\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#JuLS.SumInvariant","page":"DAG","title":"JuLS.SumInvariant","text":"SumInvariant <: StatelessInvariant\n\nInvariant that enforces y = ∑ x_i\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#Comparison-Invariants","page":"DAG","title":"Comparison Invariants","text":"","category":"section"},{"location":"api/dag/#JuLS.ComparatorInvariant","page":"DAG","title":"JuLS.ComparatorInvariant","text":"ComparatorInvariant <: SummableDeltaInvariant\n\nInvariant that compares a sum of values against a capacity threshold, typically used in constrained optimization problems. y = max(0, ∑ x - C)\n\nFields\n\ncurrent_value::Float64: Current accumulated sum\noriginal_capacity::Float64: Threshold value for comparison\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#Boolean-Invariants","page":"DAG","title":"Boolean Invariants","text":"","category":"section"},{"location":"api/dag/#JuLS.AndInvariant","page":"DAG","title":"JuLS.AndInvariant","text":"AndInvariant <: Invariant\n\nRepresents an invariant for the logical AND constraint. y = x1 ∩ x2 ∩ ... ∩ x_n\n\nFields\n\nnb_false::Int: Number of variables currently false.\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#JuLS.OrInvariant","page":"DAG","title":"JuLS.OrInvariant","text":"OrInvariant <: Invariant\n\nRepresents an invariant for the logical OR constraint. y = x1 ∪ x2 ∪ ... ∪ x_n\n\nFields\n\nnb_trues::Int: Number of variables currently true.\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#Specialized-Invariants","page":"DAG","title":"Specialized Invariants","text":"","category":"section"},{"location":"api/dag/#JuLS.AllDifferentInvariant","page":"DAG","title":"JuLS.AllDifferentInvariant","text":"struct AllDifferentInvariant <: Invariant\n\nAn invariant that enforces all variables to have different values.\n\nDescription\n\nRepresents the constraint x₁ ≠ x₂ ≠ ... ≠ xₙ where each variable xᵢ takes values  in the domain D = {1,...,n}.\n\nViolation Measure\n\nThe violation is calculated as:     y = ∑ max(0, c(i) - 1) where c(i) is the count of variables taking value i.\n\nFields\n\ncurrent_value_counter::Vector{Int}: Counts occurrences of each value in the current assignment\n\nConstructor\n\nAllDifferentInvariant(n_variables::Int)\n\nCreates an AllDifferentInvariant for n_variables variables, initializing the counter to zeros.\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#JuLS.AmongInvariant","page":"DAG","title":"JuLS.AmongInvariant","text":"AmongInvariant <: StatelessInvariant\n\nThis invariant represents the constraint Among(X, S, n) which enforces  y = |{x ∈ X : x.value ∈ S}|\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#JuLS.ElementInvariant","page":"DAG","title":"JuLS.ElementInvariant","text":"struct ElementInvariant{T} <: StatelessInvariant where {T<:DecisionValue}\n\nGiven a message with an IntDecisionValue i, the ElementInvariant returns elements[i] which is a message with a DecisionValue of type T. y = elements[x]\n\n\n\n\n\n","category":"type"},{"location":"api/dag/#DAG-Operations","page":"DAG","title":"DAG Operations","text":"","category":"section"},{"location":"api/dag/#Adding-Invariants","page":"DAG","title":"Adding Invariants","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"# Add an invariant to the DAG\ninvariant_id = add_invariant!(dag, ScalarProductInvariant(weights); variable_parent_indexes = [1, 2, 3])","category":"page"},{"location":"api/dag/#Message-Passing","page":"DAG","title":"Message Passing","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"The DAG uses message passing for efficient computation:","category":"page"},{"location":"api/dag/#Message-Types","page":"DAG","title":"Message Types","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"FullMessage: Complete state information\nDelta: Incremental changes only","category":"page"},{"location":"api/dag/#Example-Usage","page":"DAG","title":"Example Usage","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"using JuLS\n\n# Create a DAG for a simple problem\ndag = DAG(3)  # 3 decision variables\n\n# Add scalar product invariant\nweights = [2.0, 3.0, 1.0]\nsum_id = add_invariant!(dag, ScalarProductInvariant(weights); variable_parent_indexes = [1, 2, 3])\n\n# Add comparator for constraint\ncapacity = 10.0\nconstraint_id = add_invariant!(dag, ComparatorInvariant(capacity); variable_parent_indexes = [1, 2, 3])\n\n# Connect sum to constraint\nconnect!(dag, sum_id, constraint_id)\n\n# Set objective\nobjective_weights = [5.0, 4.0, 3.0]\nobj_id = add_invariant!(dag, ScalarProductInvariant(objective_weights); variable_parent_indexes= [1, 2, 3])\nadd_invariant!(dag, ObjectiveInvariant(); invariant_parent_indexes= [obj_id])","category":"page"},{"location":"api/dag/#Performance-Considerations","page":"DAG","title":"Performance Considerations","text":"","category":"section"},{"location":"api/dag/#Memory-Usage","page":"DAG","title":"Memory Usage","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"DAGs store computation history for efficiency\nConsider clearing history for long runs\nMonitor memory usage for large problems","category":"page"},{"location":"api/dag/#Computation-Efficiency","page":"DAG","title":"Computation Efficiency","text":"","category":"section"},{"location":"api/dag/","page":"DAG","title":"DAG","text":"Use appropriate invariant types\nMinimize unnecessary connections\nBatch updates when possible","category":"page"},{"location":"examples/tsp/#Traveling-Salesman-Problem-Example","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem Example","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"This example demonstrates how to solve a TSP using JuLS.jl.","category":"page"},{"location":"examples/tsp/#Problem-Description","page":"Traveling Salesman Problem","title":"Problem Description","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"The Traveling Salesman Problem (TSP) involves:","category":"page"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"A set of cities with distances between them\nGoal: find the shortest route visiting all cities exactly once\nReturn to the starting city","category":"page"},{"location":"examples/tsp/#Basic-Usage","page":"Traveling Salesman Problem","title":"Basic Usage","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"using JuLS\n\n# Load a TSP instance\ndata_path = joinpath(JuLS.PROJECT_ROOT, \"data\", \"tsp\", \"tsp_5_1\")\nexperiment = TSPExperiment(data_path)\n\n# Create and run the model\nmodel = init_model(\n    experiment;\n    init = ChristofidesInitialization(),\n    neigh = KOptNeighbourhood(5, 2),  # 5 moves, 2-opt\n    pick = SimulatedAnnealing(100.0, 0.95),  # T0=100.0, α=0.95\n    using_cp = true\n)\n\n# Optimize for 1000 iterations\noptimize!(model; limit = IterationLimit(1000))\n\n# Display results\nprintln(\"Best tour length: \", model.best_solution.objective)\nprintln(\"Tour: \", model.best_solution.values)","category":"page"},{"location":"examples/tsp/#Data-Format","page":"Traveling Salesman Problem","title":"Data Format","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"TSP data files contain distance matrices or coordinate information.","category":"page"},{"location":"examples/tsp/#Initialization-Strategies","page":"Traveling Salesman Problem","title":"Initialization Strategies","text":"","category":"section"},{"location":"examples/tsp/#Christofides-Algorithm","page":"Traveling Salesman Problem","title":"Christofides Algorithm","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"Provides high-quality starting solutions:","category":"page"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"init = ChristofidesInitialization()","category":"page"},{"location":"examples/tsp/#Simple-Random","page":"Traveling Salesman Problem","title":"Simple Random","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"Random permutation of cities:","category":"page"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"init = SimpleInitialization()","category":"page"},{"location":"examples/tsp/#Neighbourhood-Strategies","page":"Traveling Salesman Problem","title":"Neighbourhood Strategies","text":"","category":"section"},{"location":"examples/tsp/#2-opt-Moves","page":"Traveling Salesman Problem","title":"2-opt Moves","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"Most common for TSP:","category":"page"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"neigh = KOptNeighbourhood(5, 2)  # 5 moves, 2-opt","category":"page"},{"location":"examples/tsp/#3-opt-Moves","page":"Traveling Salesman Problem","title":"3-opt Moves","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"More thorough but slower:","category":"page"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"neigh = KOptNeighbourhood(3, 3)  # 3 moves, 3-opt","category":"page"},{"location":"examples/tsp/#Move-Selection","page":"Traveling Salesman Problem","title":"Move Selection","text":"","category":"section"},{"location":"examples/tsp/#Simulated-Annealing","page":"Traveling Salesman Problem","title":"Simulated Annealing","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"Recommended for TSP:","category":"page"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"pick = SimulatedAnnealing(100.0, 0.95)  # T0=100.0, α=0.95","category":"page"},{"location":"examples/tsp/#Next-Steps","page":"Traveling Salesman Problem","title":"Next Steps","text":"","category":"section"},{"location":"examples/tsp/","page":"Traveling Salesman Problem","title":"Traveling Salesman Problem","text":"Try the Graph Coloring Example\nLearn about Custom Heuristics\nExplore DAG construction for TSP","category":"page"},{"location":"#JuLS.jl-Documentation","page":"Home","title":"JuLS.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuLS is a Julia Local Search solver that combines Constraint Based Local Search (CBLS) and Constraint Programming (CP) to solve Constraint Optimization Problems (COP). It is designed as an open source project that provides the capability to solve combinatorial and black box optimization problems.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hybrid Approach: Combines CBLS and CP for efficient optimization\nFlexible Architecture: Modular design allowing custom heuristics and constraints\nMultiple Problem Types: Support for various combinatorial optimization problems\nExtensible: Easy to add new problem types and solution strategies","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuLS\n\n# Create an experiment (e.g., Knapsack problem)\ndata_path = joinpath(JuLS.PROJECT_ROOT, \"data\", \"knapsack\", \"ks_4_0\")\nexperiment = KnapsackExperiment(data_path)\n\n# Initialize a model\nmodel = init_model(\n    experiment; \n    init = SimpleInitialization(),\n    neigh = BinaryRandomNeighbourhood(10, 2),  # 10 moves, 2 variables per move\n    pick = GreedyMoveSelection(),\n    using_cp = true\n)\n\n# Optimize\noptimize!(model; limit = IterationLimit(100))\n\n# Check results\nprintln(\"Best objective: \", model.best_solution.objective)\nprintln(\"Best solution: \", model.best_solution.values)","category":"page"},{"location":"#Architecture-Overview","page":"Home","title":"Architecture Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuLS is built around several key components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Model: The Local Search model that optimizes the problem\nDAG: Directed Acyclic Graph structure for constraint and objective evaluation\nCP: Constraint Programming solver for efficient move filtering\nHeuristics: Initialization, neighbourhood, and move selection strategies\nExperiments: Problem-specific implementations and data handling","category":"page"},{"location":"#Supported-Problems","page":"Home","title":"Supported Problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuLS comes with built-in support for several classic optimization problems:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Knapsack Problem: Binary optimization with capacity constraints\nTraveling Salesman Problem (TSP): Route optimization with distance minimization\nGraph Coloring Problem: Vertex coloring with adjacency constraints","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although, JuLS is designed to build custom experiments, especially giving the possibility to solve highly-dimensional combinatorial and black box optimization problems.","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the Getting Started guide for installation and basic usage\nBrowse the User Guide for detailed explanations of core concepts\nSee Examples for complete problem implementations\nRefer to the API Reference for detailed function documentation","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JuLS is licensed under the Apache License 2.0. See the LICENSE file for details.","category":"page"},{"location":"api/heuristics/#Heuristics-API","page":"Heuristics","title":"Heuristics API","text":"","category":"section"},{"location":"api/heuristics/","page":"Heuristics","title":"Heuristics","text":"The Heuristics API provides the optimization strategies for initialization, neighbourhood exploration, and move selection.","category":"page"},{"location":"api/heuristics/#Initialization-Heuristics","page":"Heuristics","title":"Initialization Heuristics","text":"","category":"section"},{"location":"api/heuristics/#JuLS.SimpleInitialization","page":"Heuristics","title":"JuLS.SimpleInitialization","text":"SimpleInitialization <: InitializationHeuristic\n\nA basic initialization strategy that typically assigns default or random values to variables. Must be implemented as (::SimpleInitialization)(e::YourExperiment) and return a vector of values indexed by decision variables.\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.GreedyInitialization","page":"Heuristics","title":"JuLS.GreedyInitialization","text":"GreedyInitialization <: InitializationHeuristic\n\nAn initialization strategy that uses a greedy approach to assign initial values. Must be implemented as (::GreedyInitialization)(e::YourExperiment) and return a vector of values indexed by decision variables.\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.ChristofidesInitialization","page":"Heuristics","title":"JuLS.ChristofidesInitialization","text":"function (::ChristofidesInitialization)(e::TSPExperiment)\n\nInitialization strategy using Christofides algorithm for metric TSP. Provides a 1.5-approximation guarantee for metric instances.\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#Neighbourhood-Heuristics","page":"Heuristics","title":"Neighbourhood Heuristics","text":"","category":"section"},{"location":"api/heuristics/#JuLS.RandomNeighbourhood","page":"Heuristics","title":"JuLS.RandomNeighbourhood","text":"RandomNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy that randomly samples variables and assigns them random values from their domains.\n\nFields\n\nvariable_sampler::VariableSampler: Strategy for selecting variables\nnumber_of_variables_to_move::Int: Number of variables to modify in each move\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.BinaryRandomNeighbourhood","page":"Heuristics","title":"JuLS.BinaryRandomNeighbourhood","text":"BinaryRandomNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy for binary optimization problems that randomly selects and flips variables.\n\nFields\n\nnumber_of_moves::Int: Number of moves to generate in each neighbourhood\nnumber_of_variables_to_move::Int: Number of variables to flip in each move\n\nDescription\n\nGenerates moves by randomly selecting a specified number of binary variables and flipping their values (0->1 or 1->0) in each move. This creates a neighbourhood of potential solutions around the current solution.\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.BinarySingleNeighbourhood","page":"Heuristics","title":"JuLS.BinarySingleNeighbourhood","text":"BinarySingleNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy for binary optimization problems that generates all possible moves where exactly one binary variable is flipped. \n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.SwapNeighbourhood","page":"Heuristics","title":"JuLS.SwapNeighbourhood","text":"SwapNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy that creates moves by swapping values between selected variables through circular shifting.\n\nFields\n\nvariable_sampler::VariableSampler: Strategy for selecting variables to swap\nnumber_of_variables_to_move::Int: Number of variables involved in each swap (default: 2)\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.KOptNeighbourhood","page":"Heuristics","title":"JuLS.KOptNeighbourhood","text":"KOptNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy that creates k-opt moves by permuting values among k selected variables.\n\nFields\n\nnumber_of_moves::Int: Number of different k-opt moves to generate\nk::Int: Number of variables involved in each permutation\n\nDescription\n\nImplements a k-opt neighbourhood where k variables are selected and their values are permuted to create new potential solutions. This is particularly useful for problems\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.ExhaustiveNeighbourhood","page":"Heuristics","title":"JuLS.ExhaustiveNeighbourhood","text":"ExhaustiveNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy that exhaustively explores all possible value combinations for a selected subset of variables. This is equivalent to relax domains for the variables sampled.\n\nFields\n\nnumber_of_variables_to_move::Int: Number of variables to consider in each move\nvariable_sampler::VariableSampler: Strategy for selecting which variables to consider\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.GreedyNeighbourhood","page":"Heuristics","title":"JuLS.GreedyNeighbourhood","text":"GreedyNeighbourhood <: NeighbourhoodHeuristic\n\nA neighbourhood generation strategy that greedily explores variables based on their potential improvement at initialization.\n\nFields\n\nqueue::Vector{LazyCartesianMoves}: Ordered queue of moves to explore\n_is_init::Bool: Flag indicating if the neighbourhood has been initialized\n\nDescription\n\nThis heuristic evaluates each variable's potential contribution to improvement and orders the exploration based on these evaluations. Variables are explored in order of their potential impact on the objective function.\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#Move-Selection-Heuristics","page":"Heuristics","title":"Move Selection Heuristics","text":"","category":"section"},{"location":"api/heuristics/#JuLS.GreedyMoveSelection","page":"Heuristics","title":"JuLS.GreedyMoveSelection","text":"GreedyMoveSelection <: MoveSelectionHeuristic\n\nGreedy move selection heuristic. Always pick the most impactful move.\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.SimulatedAnnealing","page":"Heuristics","title":"JuLS.SimulatedAnnealing","text":"Metropolis <: MoveSelectionHeuristic\n\nFields\n\n-T::Float64: Temperature -α::Float64: Cooling factor -T_min::Float64 : Minimal temperature\n\nOf all the moves given, take the best delta, return it if negative or return it with probability exp(-δ/T).\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#JuLS.Metropolis","page":"Heuristics","title":"JuLS.Metropolis","text":"Metropolis <: MoveSelectionHeuristic\n\nFields\n\nT::Float64: Temperature for metropolis probability\n\nOf all the moves given, take the best delta, return it if negative or return it with probability exp(-δ/T).\n\n\n\n\n\n","category":"type"},{"location":"api/heuristics/#Custom-Heuristics","page":"Heuristics","title":"Custom Heuristics","text":"","category":"section"},{"location":"api/heuristics/","page":"Heuristics","title":"Heuristics","text":"To create custom heuristics, implement the appropriate abstract type:","category":"page"},{"location":"api/heuristics/","page":"Heuristics","title":"Heuristics","text":"InitializationHeuristic: For custom initialization strategies\nNeighbourhoodHeuristic: For custom neighbourhood exploration\nMoveSelectionHeuristic: For custom move selection criteria","category":"page"},{"location":"api/heuristics/#Example-Usage","page":"Heuristics","title":"Example Usage","text":"","category":"section"},{"location":"api/heuristics/","page":"Heuristics","title":"Heuristics","text":"```julia using JuLS","category":"page"},{"location":"api/heuristics/#Initialize-with-different-heuristics","page":"Heuristics","title":"Initialize with different heuristics","text":"","category":"section"},{"location":"api/heuristics/","page":"Heuristics","title":"Heuristics","text":"model = initmodel(     experiment;     init = GreedyInitialization(),     neigh = KOptNeighbourhood(5, 2),  # nmoves, k     pick = SimulatedAnnealing(100.0, 0.95)  # T0, α )","category":"page"},{"location":"examples/knapsack/#Knapsack-Problem-Example","page":"Knapsack Problem","title":"Knapsack Problem Example","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"This example demonstrates how to solve a knapsack problem using JuLS.jl.","category":"page"},{"location":"examples/knapsack/#Problem-Description","page":"Knapsack Problem","title":"Problem Description","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"The knapsack problem is a classic optimization problem where you have:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"A knapsack with limited capacity\nA set of items, each with a weight and value\nGoal: maximize total value while staying within capacity constraint","category":"page"},{"location":"examples/knapsack/#Basic-Usage","page":"Knapsack Problem","title":"Basic Usage","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"using JuLS\n\n# Load a knapsack instance\ndata_path = joinpath(JuLS.PROJECT_ROOT, \"data\", \"knapsack\", \"ks_4_0\")\nexperiment = KnapsackExperiment(data_path)\n\n# Create and run the model\nmodel = init_model(\n    experiment;\n    init = SimpleInitialization(),\n    neigh = BinaryRandomNeighbourhood(10, 2),  # 10 moves, 2 variables per move\n    pick = GreedyMoveSelection(),\n    using_cp = true\n)\n\n# Optimize for 1000 iterations\noptimize!(model; limit = IterationLimit(1000))\n\n# Display results\nprintln(\"Best objective value: \", model.best_solution.objective)\nprintln(\"Items selected: \", model.best_solution.values)","category":"page"},{"location":"examples/knapsack/#Data-Format","page":"Knapsack Problem","title":"Data Format","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"The knapsack data file format is:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"n_items capacity\nweight_1 value_1\nweight_2 value_2\n...\nweight_n value_n","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"Example file content:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"4 11\n8 4\n10 5\n15 8\n4 3","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"This represents:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"4 items with capacity 11\nItem 1: weight=8, value=4\nItem 2: weight=10, value=5\nItem 3: weight=15, value=8\nItem 4: weight=4, value=3","category":"page"},{"location":"examples/knapsack/#Advanced-Configuration","page":"Knapsack Problem","title":"Advanced Configuration","text":"","category":"section"},{"location":"examples/knapsack/#Custom-Initialization","page":"Knapsack Problem","title":"Custom Initialization","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"Use greedy initialization for better starting solutions:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"model = init_model(\n    experiment;\n    init = GreedyInitialization(),  # Start with greedy solution\n    neigh = BinaryRandomNeighbourhood(10, 2),\n    pick = GreedyMoveSelection(),\n    using_cp = true\n)","category":"page"},{"location":"examples/knapsack/#Different-Neighbourhood-Strategies","page":"Knapsack Problem","title":"Different Neighbourhood Strategies","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"Try different neighbourhood exploration strategies:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"# Single bit flip neighbourhood\nmodel = init_model(\n    experiment;\n    neigh = BinarySingleNeighbourhood(),\n    # ... other parameters\n)\n\n# Exhaustive neighbourhood (for small problems)\nmodel = init_model(\n    experiment;\n    neigh = ExhaustiveNeighbourhood(),\n    # ... other parameters\n)","category":"page"},{"location":"examples/knapsack/#Move-Selection-Heuristics","page":"Knapsack Problem","title":"Move Selection Heuristics","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"Experiment with different move selection strategies:","category":"page"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"# Simulated annealing\nmodel = init_model(\n    experiment;\n    pick = SimulatedAnnealing(100.0, 0.95),  # T0=100.0, α=0.95\n    # ... other parameters\n)\n\n# Metropolis criterion\nmodel = init_model(\n    experiment;\n    pick = Metropolis(10.0),  # T=10.0\n    # ... other parameters\n)","category":"page"},{"location":"examples/knapsack/#Common-Issues","page":"Knapsack Problem","title":"Common Issues","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"Infeasible solutions: Check that your initialization respects capacity constraints\nNo improvements: Try different heuristic combinations or increase iteration limit\nSlow convergence: Enable CP filtering or use better initialization strategies","category":"page"},{"location":"examples/knapsack/#Next-Steps","page":"Knapsack Problem","title":"Next Steps","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack Problem","title":"Knapsack Problem","text":"Try the TSP Example for a different problem type\nLearn about Custom Heuristics\nExplore the DAG structure for constraint modeling","category":"page"}]
}
